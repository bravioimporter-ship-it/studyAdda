<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>StudyVault — Secure Study Chat</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#6ee7b7; --muted:#94a3b8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029,#091025);color:#e6eef8;font-family:Inter,system-ui,Arial;}
  .wrap{display:flex;flex-direction:column;height:100vh;gap:8px;padding:12px;}
  .lock-overlay{position:fixed;inset:0;background:linear-gradient(180deg, rgba(2,6,23,0.95), rgba(2,8,27,0.98));z-index:1000;display:flex;align-items:center;justify-content:center}
  .lock-card{width:min(520px,96vw);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:16px;padding:22px;}
  .brand{display:flex;gap:12px;align-items:center;margin-bottom:6px;}
  .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#60a5fa);display:flex;align-items:center;justify-content:center;font-weight:700;color:#022}
  h1{font-size:18px;margin:0}
  .pass-row{display:flex;gap:10px;align-items:center}
  input.pass{flex:1;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:16px}
  button.unlock{padding:10px 16px;border-radius:10px;border:none;background:linear-gradient(90deg,var(--accent),#60a5fa);color:#001;font-weight:700;cursor:pointer}
  .content{display:flex;flex:1;gap:12px;align-items:stretch}
  .left{flex:1;display:flex;flex-direction:column;gap:8px}
  .pdfwrap{background:rgba(255,255,255,0.02);border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;height:100%}
  .embedarea{flex:1;background:#000;min-height:320px;display:flex}
  .embedarea iframe{width:100%;height:100%;border:none}
  .open-disc-btn{display:block;width:100%;padding:14px;border:none;border-top:1px solid rgba(255,255,255,0.02);background:linear-gradient(90deg,#0f1724,#081224);color:var(--accent);font-weight:700;cursor:pointer;position:relative;z-index:2}
  .right{width:420px;max-width:45%;min-width:300px;display:flex;flex-direction:column;gap:8px}
  .chat-card{flex:1;border-radius:12px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
  .topbar{display:flex;align-items:center;justify-content:space-between}
  .label-wrap{display:flex;flex-direction:column}
  .labelName{font-weight:700}
  .presence-line{display:flex;align-items:center;gap:8px}
  .presence-dot{width:12px;height:12px;border-radius:50%;background:#7f1d1d;display:inline-block;box-shadow:0 0 8px rgba(0,0,0,0.4)}
  .msgs{flex:1;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}
  .msg.me{align-self:flex-end;background:linear-gradient(90deg,var(--accent),#60a5fa);color:#022;padding:10px 12px;border-radius:12px;max-width:80%;position:relative}
  .msg.them{align-self:flex-start;background:rgba(255,255,255,0.03);padding:10px 12px;border-radius:12px;max-width:80%;color:var(--muted)}
  .meta{font-size:11px;color:var(--muted);margin-top:6px}
  .typing{font-size:13px;color:var(--muted);height:18px}
  .composer{display:flex;gap:8px;align-items:center;padding-top:6px}
  textarea.input{flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-height:44px;resize:none;background:transparent;color:inherit}
  button.send{padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#60a5fa,var(--accent));color:#022;font-weight:700;cursor:pointer}
  button.back{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);cursor:pointer}
  .read-indicator{font-size:12px;color:#94a3b8;margin-left:8px}
  .read-indicator.read{color:#34d399} /* green when read */
  @media (max-width:900px){ .content{flex-direction:column} .right{width:100%;max-width:100%;min-width:unset} .chat-card{height:48vh;order:2} .pdfwrap{height:calc(52vh - 12px)} .open-disc-btn{position:sticky;bottom:0;z-index:30} input.pass{font-size:18px;padding:14px} }
</style>
</head>
<body>
<div class="wrap">

  <!-- LOCK OVERLAY -->
  <div id="lock" class="lock-overlay" aria-hidden="false">
    <div class="lock-card">
      <div class="brand">
        <div class="logo">SV</div>
        <div>
          <h1>StudyVault — Secure Study Page</h1>
          <p class="lead" style="color:#94a3b8;margin:6px 0 14px;font-size:13px">This page is locked. Enter passcode to view the document and open discussions.</p>
        </div>
      </div>

      <div>
        <div class="pass-row">
          <input id="passInput" class="pass" type="password" placeholder="" />
          <button id="unlockBtn" class="unlock">Unlock</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MAIN -->
  <div id="main" style="display:none" class="content" aria-hidden="true">
    <div class="left">
      <div class="pdfwrap">
        <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent)">
          <div style="font-weight:600">Economics — Study Paper (embedded)</div>
          <div style="color:#94a3b8;font-size:13px">Preview</div>
        </div>
        <div class="embedarea" id="pdfContainer">
          <iframe id="pdfIframe" src="Economics-SQP.pdf" allowfullscreen></iframe>
        </div>
        <button id="openDiscussionsBtn" class="open-disc-btn">Open Discussions</button>
      </div>
    </div>

    <div class="right">
      <div class="chat-card" id="chatCard" style="display:none">
        <div class="topbar">
          <div class="label-wrap">
            <div id="labelName" class="labelName">studyAdda</div>
            <div id="presenceWrap" class="presence-line" style="display:none">
              <span id="presenceDot" class="presence-dot" title="Offline"></span>
              <span id="presenceText" style="color:#94a3b8;font-size:13px">Offline</span>
            </div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="backBtn" class="back">Back to the page</button>
          </div>
        </div>

        <div class="msgs" id="messages"></div>
        <div id="typingIndicator" class="typing"></div>

        <div class="composer">
          <textarea id="inputBox" class="input" placeholder="Type a message..." rows="2"></textarea>
          <button id="sendBtn" class="send">Send</button>
        </div>
      </div>

      <div id="chatHint" style="display:flex;align-items:center;gap:8px;flex-direction:column;justify-content:center;border-radius:12px;padding:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);min-height:120px">
        <div style="font-weight:600">Discussions are private & encrypted</div>
        <div style="color:#94a3b8;font-size:13px">Open the discussions after reading the document to chat with each other.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------------- CONFIG ---------------- */
const SIGNALING_SERVER = 'wss://study-signal.bravioimporter.workers.dev/'; // your worker wss
const NOTIFY_URL = 'https://study-signal.bravioimporter.workers.dev/notify';
const NOTIFY_SECRET_CLIENT = 'studyvault2511';
const CHAT_SECRET = 'studyvault-chat-secret-2025';
const ROOM = 'room1';

/* ---------------- UI refs ---------------- */
const lock = document.getElementById('lock');
const main = document.getElementById('main');
const passInput = document.getElementById('passInput');
const unlockBtn = document.getElementById('unlockBtn');
const openDiscussionsBtn = document.getElementById('openDiscussionsBtn');
const chatCard = document.getElementById('chatCard');
const chatHint = document.getElementById('chatHint');
const messagesDiv = document.getElementById('messages');
const labelName = document.getElementById('labelName');
const presenceWrap = document.getElementById('presenceWrap');
const presenceDot = document.getElementById('presenceDot');
const presenceText = document.getElementById('presenceText');
const typingIndicator = document.getElementById('typingIndicator');
const inputBox = document.getElementById('inputBox');
const sendBtn = document.getElementById('sendBtn');
const backBtn = document.getElementById('backBtn');

/* ---------------- State ---------------- */
let unlocked = false;
let localName = 'studyAdda'; // default before unlock
let cryptoKey = null;
let ws = null;
let connecting = false; // prevent concurrent connects
let typingTO = null;
const presenceByName = {}; // map name -> 'offline'|'on-page'|'on-chat'

let messagesStore = []; // array of {mid,text,who,read}
const processedMids = new Set();

/* ---------- crypto helpers ---------- */
function bufToBase64(buf){ const arr=Array.from(new Uint8Array(buf)); return btoa(arr.map(c=>String.fromCharCode(c)).join('')); }
function base64ToBuf(b64){ const binary = atob(b64); const len=binary.length; const bytes=new Uint8Array(len); for(let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i); return bytes.buffer; }
async function deriveKeyFromSecret(secret){
  const salt = new TextEncoder().encode('studyvault-salt-2025');
  const enc = new TextEncoder().encode(secret);
  const baseKey = await crypto.subtle.importKey('raw', enc, { name: 'PBKDF2' }, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 150000, hash: 'SHA-256' }, baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt','decrypt']);
  return key;
}
async function encryptMessage(plain){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(plain);
  const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, cryptoKey, enc);
  return { iv: bufToBase64(iv.buffer), payload: bufToBase64(cipher) };
}
async function decryptMessage(ivB64, payloadB64){
  try{
    const iv = base64ToBuf(ivB64);
    const data = base64ToBuf(payloadB64);
    const plainBuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, cryptoKey, data);
    return new TextDecoder().decode(plainBuf);
  } catch(e){ return null; }
}

/* ---------- Message / UI helpers ---------- */
function persistMessagesStore(){
  try{ sessionStorage.setItem('sv_msgs', JSON.stringify(messagesStore)); } catch(e){}
}
function appendMessage(text, whoIs, mid=null, read=false){
  if(mid && messagesStore.some(m => m.mid === mid)) {
    if(read){
      const m = messagesStore.find(x => x.mid === mid);
      if(m) m.read = true;
      persistMessagesStore();
      const dom = messagesDiv.querySelector(`[data-mid="${mid}"]`);
      if(dom && dom.classList.contains('me')){
        let r = dom.querySelector('.read-indicator');
        if(!r){ r = document.createElement('span'); r.className='read-indicator'; r.style.marginLeft='8px'; dom.appendChild(r); }
        r.classList.add('read'); r.textContent='✓ read';
      }
    }
    return;
  }

  const msgObj = { mid: mid || null, text, who: whoIs, read: !!read };
  messagesStore.push(msgObj);
  persistMessagesStore();

  const el = document.createElement('div');
  el.className = whoIs === 'me' ? 'msg me' : 'msg them';
  el.textContent = text;
  if(mid) el.dataset.mid = mid;
  if(whoIs === 'me' && localName === 'studyAdda'){
    const r = document.createElement('span');
    r.className = 'read-indicator' + (read ? ' read' : '');
    r.textContent = read ? '✓ read' : '✓';
    r.style.marginLeft = '8px';
    el.appendChild(r);
  }
  messagesDiv.appendChild(el);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function loadSessionMessages(){
  const raw = sessionStorage.getItem('sv_msgs');
  if(!raw) return false;
  try{
    messagesStore = JSON.parse(raw) || [];
    messagesDiv.innerHTML = '';
    messagesStore.forEach(it=>{
      const el = document.createElement('div');
      el.className = it.who === 'me' ? 'msg me' : 'msg them';
      el.textContent = it.text;
      if(it.mid) el.dataset.mid = it.mid;
      if(it.who === 'me' && localName === 'studyAdda'){
        const r = document.createElement('span');
        r.className = 'read-indicator' + (it.read ? ' read' : '');
        r.textContent = it.read ? '✓ read' : '✓';
        r.style.marginLeft='8px';
        el.appendChild(r);
      }
      messagesDiv.appendChild(el);
    });
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    return true;
  } catch(e){ messagesStore = []; return false; }
}

const PRELOADED = [
  { who:'them', text: "Check section 3's aggregate demand graph — the shift is caused by fiscal stimulus."},
  { who:'me', text: "Yes. With MPC=0.8 the multiplier is 5 — they used that in the example."},
  { who:'them', text: "Page 12's supply curve discussion clarifies short-run vs long-run."},
  { who:'me', text: "Don't forget the price-stickiness assumption — it's key to the result."}
];

/* ---------- Presence + heartbeat + staleness check (REPLACEMENT) ----------
   Reliable presence: broadcasts presence with a timestamp (ts).
   Other clients keep lastSeen[name] and a monitor marks offline if stale.
*/

const lastSeen = {}; // name -> lastSeen timestamp (ms)
const PRESENCE_STALE_MS = 15000; // 15 seconds -> mark offline
const PRESENCE_CHECK_INTERVAL = 5000; // check every 5s
let presenceMonitorHandle = null;

// Render presence (only visible to studyAdda)
function renderPresenceUI(){
  if(localName !== 'studyAdda'){ presenceWrap.style.display='none'; return; }
  presenceWrap.style.display='flex';
  const status = presenceByName['You'] || 'offline';
  if(status === 'offline'){ presenceDot.style.background = '#7f1d1d'; presenceText.textContent='Offline'; presenceDot.title='Offline'; }
  else if(status === 'on-page'){ presenceDot.style.background = '#d97706'; presenceText.textContent='On page'; presenceDot.title='On page'; }
  else if(status === 'on-chat'){ presenceDot.style.background = '#10b981'; presenceText.textContent='In chat'; presenceDot.title='In chat'; }
}

// Send presence with timestamp (heartbeat)
async function sendPresence(status){
  const ts = Date.now();
  const msg = { type:'presence', status, name: localName, ts };
  try{
    // Try websocket first
    if(!ws || ws.readyState !== WebSocket.OPEN){
      await connectSignaling();
      // small delay to allow WS open
      await new Promise(r => setTimeout(r, 120));
    }
    if(ws && ws.readyState === WebSocket.OPEN){
      ws.send(JSON.stringify(msg));
      // update our own lastSeen so others don't think we're offline instantly
      lastSeen[localName] = ts;
    } else {
      // best-effort: fallback to navigator.sendBeacon to inform Worker (optional)
      try {
        if (navigator.sendBeacon) {
          const b = new Blob([JSON.stringify(msg)], { type: 'application/json' });
          navigator.sendBeacon(NOTIFY_URL, b); // this uses your notify endpoint as a fallback (must accept)
        }
      } catch(_) {}
    }
  }catch(e){
    console.warn('presence send failed', e);
  }
}

// Handler when presence messages are received over WS
function handleIncomingPresence(data){
  if(!data || !data.name) return;
  presenceByName[data.name] = data.status || 'offline';
  lastSeen[data.name] = Number(data.ts) || Date.now();
  renderPresenceUI();
}

// Monitor: mark stale peers offline after PRESENCE_STALE_MS
function startPresenceMonitor(){
  if(presenceMonitorHandle) return;
  presenceMonitorHandle = setInterval(()=> {
    const now = Date.now();
    let changed = false;
    for(const name of Object.keys(lastSeen)){
      const delta = now - (lastSeen[name] || 0);
      if(delta > PRESENCE_STALE_MS){
        if(presenceByName[name] !== 'offline'){
          presenceByName[name] = 'offline';
          changed = true;
        }
      }
    }
    if(changed) renderPresenceUI();
  }, PRESENCE_CHECK_INTERVAL);
}
function stopPresenceMonitor(){
  if(presenceMonitorHandle){ clearInterval(presenceMonitorHandle); presenceMonitorHandle = null; }
}

// Start heartbeat interval for this client (every 6s) — helps other clients see us
let heartbeatHandle = null;
function startHeartbeat(){
  if(heartbeatHandle) return;
  // send initial presence immediately
  const statusNow = (chatCard && chatCard.style.display === 'flex') ? 'on-chat' : 'on-page';
  sendPresence(statusNow);
  heartbeatHandle = setInterval(()=> {
    const s = (chatCard && chatCard.style.display === 'flex') ? 'on-chat' : 'on-page';
    sendPresence(s);
  }, 6000);
}
function stopHeartbeat(){
  if(heartbeatHandle){ clearInterval(heartbeatHandle); heartbeatHandle = null; }
}

/* ---------- Notify function (improved) ---------- */
async function notifyServerIfSheIsYou(){
  try{
    if(localName !== 'You') return;
    const payload = { secret: NOTIFY_SECRET_CLIENT, who:'You', room:ROOM, ts: Date.now() };
    console.log('notify: sending', payload);
    const doFetch = async ()=> {
      const r = await fetch(NOTIFY_URL, { method:'POST', headers:{ 'Content-Type':'application/json', 'x-notify-secret': NOTIFY_SECRET_CLIENT }, body: JSON.stringify(payload) });
      const text = await r.text().catch(()=>'<no-body>');
      console.log('notify: response', r.status, text);
      return { ok: r.ok, status: r.status, text };
    };
    let res = await doFetch().catch(e=>({ ok:false, error:e }));
    if(!res.ok && res.error){ console.warn('notify retry', res.error); res = await doFetch().catch(e=>({ ok:false, error:e })); }
    if(!res.ok) console.error('notify failed', res); else console.log('notify success');
  }catch(e){ console.error('notify unexpected', e); }
}

/* ---------- Signaling connection & handlers (fixed) ---------- */
async function connectSignaling(){
  if(ws && ws.readyState === WebSocket.OPEN) return;
  if(connecting) return;
  connecting = true;
  try{
    try{ if(ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) { ws.close(); } } catch(_){}
    ws = new WebSocket(SIGNALING_SERVER);

    ws.onopen = ()=>{ console.log('Signaling connected'); connecting = false; startHeartbeat(); startPresenceMonitor(); };
    ws.onclose = ()=>{ console.log('Signaling closed'); connecting = false; stopHeartbeat(); };
    ws.onerror = (e)=>{ console.warn('Signaling error', e); connecting = false; stopHeartbeat(); };

    ws.onmessage = async (evt) => {
      try{
        const data = JSON.parse(evt.data);

        if(data.type === 'presence' && data.name){
          handleIncomingPresence(data);
          return;
        }

        if(data.type === 'typing'){
          typingIndicator.textContent = data.from === localName ? '' : (data.from + ' is typing...');
          if(typingTO) clearTimeout(typingTO);
          typingTO = setTimeout(()=>{ typingIndicator.textContent=''; }, 2000);
          return;
        }

        if(data.type === 'read' && data.mid){
          const m = messagesDiv.querySelector(`[data-mid="${data.mid}"]`);
          if(m && m.classList.contains('me')){
            let r = m.querySelector('.read-indicator');
            if(!r){ r = document.createElement('span'); r.className='read-indicator'; r.style.marginLeft='8px'; m.appendChild(r); }
            r.classList.add('read'); r.textContent='✓ read';
            const st = messagesStore.find(x => x.mid === data.mid);
            if(st) { st.read = true; persistMessagesStore(); }
          }
          return;
        }

        if(data.type === 'enc'){
          if(data.mid && processedMids.has(data.mid)) return;
          if(data.mid) processedMids.add(data.mid);

          const dec = await decryptMessage(data.iv, data.payload);
          if(dec !== null){
            const whoIs = data.name === localName ? 'me' : 'them';
            appendMessage(dec, whoIs, data.mid || null, false);

            if(localName === 'You' && chatCard.style.display === 'flex' && data.mid){
              setTimeout(()=> {
                try{ if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type:'read', mid: data.mid, from: localName })); } catch(e){}
              }, 400);
            }
          }
          return;
        }
      }catch(err){ console.warn('ws message parse err', err); }
    };

  }catch(e){ console.warn('connectSignaling failed', e); connecting = false; }
}

/* ---------- Send encrypted message with single send ---------- */
async function sendMessagePlain(text){
  if(!cryptoKey) return;
  const { iv, payload } = await encryptMessage(text);
  const mid = Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8);
  appendMessage(text, 'me', mid, false);
  const obj = { type:'enc', payload, iv, name: localName, mid };
  try{ if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj)); } catch(e){ console.warn('send failed', e); }
}

/* ---------- typing ---------- */
function sendTyping(){
  if(!ws || ws.readyState !== WebSocket.OPEN) return;
  try{ ws.send(JSON.stringify({ type:'typing', from: localName })); } catch(e){}
}

/* ---------- UI actions ---------- */
unlockBtn.addEventListener('click', doUnlock);
passInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') doUnlock(); });

async function doUnlock(){
  const v = passInput.value.trim();
  if(!v) return;
  if (v === '2511') localName = 'You';
  else if (v === '2809') localName = 'studyAdda';
  else { alert('Wrong passcode'); passInput.value=''; return; }

  cryptoKey = await deriveKeyFromSecret(CHAT_SECRET);
  labelName.textContent = localName;
  lock.style.display = 'none';
  main.style.display = 'flex';
  unlocked = true;

  notifyServerIfSheIsYou();

  await connectSignaling();
  sendPresence('on-page');

  chatHint.style.display = 'flex';
  chatCard.style.display = 'none';
  messagesDiv.innerHTML = '';
  messagesStore = [];
  processedMids.clear();
  sessionStorage.removeItem('sv_msgs');
}

/* Open discussions */
openDiscussionsBtn.addEventListener('click', async ()=>{
  if(!unlocked){ alert('Please unlock first'); return; }
  chatCard.style.display = 'flex';
  chatHint.style.display = 'none';
  await connectSignaling();
  sendPresence('on-chat'); // announce in-chat
  const loaded = loadSessionMessages();
  if(!loaded){
    PRELOADED.forEach(it=> appendMessage(it.text, it.who === 'me' ? 'me' : 'them', null, false));
  }
});

/* Send */
sendBtn.addEventListener('click', async ()=>{
  const txt = inputBox.value.trim();
  if(!txt) return;
  await sendMessagePlain(txt);
  inputBox.value = '';
});

/* typing */
inputBox.addEventListener('input', ()=>{ sendTyping(); });

/* Back (leave chat, go back to page) */
backBtn.addEventListener('click', ()=>{
  messagesDiv.innerHTML=''; messagesStore = []; persistMessagesStore();
  chatCard.style.display='none'; chatHint.style.display='flex';
  sendPresence('on-page');
  try{ const pdfFrame=document.getElementById('pdfIframe'); if(pdfFrame && pdfFrame.contentWindow) pdfFrame.contentWindow.scrollTo(0,0); } catch(e){}
});

/* beforeunload -> send offline best-effort */
window.addEventListener('beforeunload', ()=>{
  try{
    if(ws && ws.readyState === WebSocket.OPEN){
      try{ ws.send(JSON.stringify({ type:'presence', status:'offline', name: localName })); } catch(_){}
    } else {
      try {
        if (navigator.sendBeacon) {
          const msg = { type:'presence', status:'offline', name: localName, ts: Date.now() };
          const b = new Blob([JSON.stringify(msg)], { type: 'application/json' });
          navigator.sendBeacon(NOTIFY_URL, b);
        }
      } catch(_) {}
    }
  }catch(e){}
  try{ sessionStorage.removeItem('sv_msgs'); } catch(e){}
  if(ws) try{ ws.close(); } catch(e){}
});

/* Enter sends */
inputBox.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendBtn.click(); } });

/* adjust embed */
function adjustEmbed(){ const wrap=document.querySelector('.pdfwrap'); if(window.innerWidth<=900) wrap.style.height='calc(52vh - 12px)'; else wrap.style.height='100%'; }
window.addEventListener('resize', adjustEmbed);
adjustEmbed();

/* debug helper */
window.SV = { debugShowState: ()=>({ localName, unlocked, wsState: ws?ws.readyState:null, presenceByName, messagesStoreLength: messagesStore.length, lastSeen }) };
</script>
</body>
</html>
